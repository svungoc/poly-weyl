<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Latex (math-latex.Latex)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous"><script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script><script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">math-latex</a> &#x00BB; Latex</nav><h1>Module <code>Latex</code></h1><p>Parsing of simple LaTeX mathematical expressions.</p><dl><dt>author</dt><dd>San Vu Ngoc, 2020, Université de Rennes 1</dd></dl><nav class="toc"><ul><li><a href="#goal">Goal</a></li><li><a href="#warnings">Warnings</a></li><li><a href="#scanning-latex">Scanning LaTeX</a><ul><li><a href="#customization">Customization</a></li></ul></li><li><a href="#writing-latex-back">Writing LaTeX back</a></li><li><a href="#display-latex">Display LaTeX</a></li></ul></nav></header><section><header><h3 id="goal"><a href="#goal" class="anchor"></a>Goal</h3><p>The goal is to recognize the mathematical meaning of strings like</p><p><code>&quot;1.41+2x+5x^2 + \\sin t^2 + \\frac{A-B}2&quot;</code></p><p>The resulting expression tree is</p><pre><code class="ml">Infix
  (Char '+',
   [Number (&quot;1&quot;, &quot;41&quot;);
    Infix (TeX &quot;_*&quot;, [Number (&quot;2&quot;, &quot;&quot;); Symbol (Char 'x')]);
    Infix
      (TeX &quot;_*&quot;,
       [Number (&quot;5&quot;, &quot;&quot;);
        Infix (Char '^', [Symbol (Char 'x'); Number (&quot;2&quot;, &quot;&quot;)])]);
    Unop (TeX &quot;sin&quot;, Infix (Char '^', [Symbol (Char 't'); Number (&quot;2&quot;, &quot;&quot;)]));
    Binop
      (TeX &quot;frac&quot;,
       Paren
         (Char '{', Infix (Char '-', [Symbol (Char 'A'); Symbol (Char 'B')])),
       Number (&quot;2&quot;, &quot;&quot;))])</code></pre></header></section><section><header><h3 id="warnings"><a href="#warnings" class="anchor"></a>Warnings</h3><p><em>Warning 1:</em> There cannot be a consistent translation between LaTeX maths and mathematical expressions, because LaTeX only expresses <b>typography</b> and not <b>mathematical meaning</b>. For instance <code>&quot;x^2&quot;</code> can both mean &quot;x to the power 2&quot; or &quot;the variable x with upper index 2&quot;.</p><p><em>Warning 2:</em> There are some differences with pure LaTeX:</p><p>* Numbers are treated like a unique symbol. Thus, <code>x^12</code> is parsed as <code>x^{12}</code> (but <code>x^2y</code> is 'correctly' parsed as <code>{x^2} * y</code>). <code>\\frac12</code> is an error, <code>\\frac12x</code> is parsed as <code>\\frac{12}{x}</code>. When in doubt, it's better to use brackets <code>{}</code>.</p><p>* Parenthesis <code>()</code> and brackets <code>[]</code> have the same role. Hence <code>x[a+b]</code> is parsed as <code>x * (a+b)</code></p><p>* Infix operators are not assumed to be associative or commutative: the order of arguments is preserved. For instance</p><pre><code class="ml"># parse &quot;a^b^c&quot;;;
- : expr =
Group (Char '^', [Symbol (Char 'a'); Symbol (Char 'b'); Symbol (Char 'c')])</code></pre><p>* Expressions like <code>\sin^2 x</code> are not allowed. Use <code>{\sin x}^2</code></p><p>* Arbitrary chars or TeX symbols can be declared as operators. For instance, if <code>f</code> is declared as a unary operator, then</p><p><code>5fx</code> ==&gt; <code>5 * f(x)</code></p><p><em>Warning 3:</em> The minus sign '-' is considered as an infix operator like '+', which can be confusing, but the result is actually easy to understand:</p><pre><code class="ml"># parse &quot;a-b-c&quot;;;
- : expr =
Group (Char '-', [Symbol (Char 'a'); Symbol (Char 'b'); Symbol (Char 'c')])</code></pre><p>The minus sign can also be transformed into a unary negation like in <code>&quot;-1&quot;</code>, but currently we do not allow this for '+' (<code>parse &quot;+1&quot;</code> raises an error); (this is for better syntax error checking.)</p></header></section><section><header><h2 id="scanning-latex"><a href="#scanning-latex" class="anchor"></a>Scanning LaTeX</h2></header><dl><dt class="spec type" id="type-number"><a href="#type-number" class="anchor"></a><code><span class="keyword">type</span> number</code><code> = string * string</code></dt><dd><p>123 is represented by <code>(&quot;123&quot;,&quot;&quot;)</code> and 12.234 is represented by <code>(&quot;12&quot;,
   &quot;234&quot;)</code>. These 'numbers' can easily be converted into 'true' numbers using for instance the Zarith library.</p></dd></dl><dl><dt class="spec type" id="type-symbol"><a href="#type-symbol" class="anchor"></a><code><span class="keyword">type</span> symbol</code><code> = </code><table class="variant"><tr id="type-symbol.Char" class="anchored"><td class="def constructor"><a href="#type-symbol.Char" class="anchor"></a><code>| </code><code><span class="constructor">Char</span> <span class="keyword">of</span> char</code></td></tr><tr id="type-symbol.TeX" class="anchored"><td class="def constructor"><a href="#type-symbol.TeX" class="anchor"></a><code>| </code><code><span class="constructor">TeX</span> <span class="keyword">of</span> string</code></td><td class="doc"><p>TeX &quot;alpha&quot; stands for &quot;\alpha&quot;</p></td></tr></table></dt><dt class="spec type" id="type-expr"><a href="#type-expr" class="anchor"></a><code><span class="keyword">and</span> expr</code><code> = </code><table class="variant"><tr id="type-expr.Number" class="anchored"><td class="def constructor"><a href="#type-expr.Number" class="anchor"></a><code>| </code><code><span class="constructor">Number</span> <span class="keyword">of</span> <a href="index.html#type-number">number</a></code></td></tr><tr id="type-expr.Symbol" class="anchored"><td class="def constructor"><a href="#type-expr.Symbol" class="anchor"></a><code>| </code><code><span class="constructor">Symbol</span> <span class="keyword">of</span> <a href="index.html#type-symbol">symbol</a></code></td></tr><tr id="type-expr.Unop" class="anchored"><td class="def constructor"><a href="#type-expr.Unop" class="anchor"></a><code>| </code><code><span class="constructor">Unop</span> <span class="keyword">of</span> <a href="index.html#type-symbol">symbol</a> * <a href="index.html#type-expr">expr</a></code></td></tr><tr id="type-expr.Binop" class="anchored"><td class="def constructor"><a href="#type-expr.Binop" class="anchor"></a><code>| </code><code><span class="constructor">Binop</span> <span class="keyword">of</span> <a href="index.html#type-symbol">symbol</a> * <a href="index.html#type-expr">expr</a> * <a href="index.html#type-expr">expr</a></code></td></tr><tr id="type-expr.Infix" class="anchored"><td class="def constructor"><a href="#type-expr.Infix" class="anchor"></a><code>| </code><code><span class="constructor">Infix</span> <span class="keyword">of</span> <a href="index.html#type-symbol">symbol</a> * <span><a href="index.html#type-expr">expr</a> list</span></code></td></tr><tr id="type-expr.Paren" class="anchored"><td class="def constructor"><a href="#type-expr.Paren" class="anchor"></a><code>| </code><code><span class="constructor">Paren</span> <span class="keyword">of</span> <a href="index.html#type-symbol">symbol</a> * <a href="index.html#type-expr">expr</a></code></td></tr></table></dt><dd><p>Mathematical expressions</p></dd></dl><dl><dt class="spec value" id="val-parse"><a href="#val-parse" class="anchor"></a><code><span class="keyword">val</span> parse : string <span class="arrow">→</span> <a href="index.html#type-expr">expr</a></code></dt><dd><p>This is the main function. Given a string containing LaTeX mathematics (without the '$'), <code>parse s</code> returns an abstract expression tree representing its mathematical content.</p><p>Example:</p><pre><code class="ml"># parse &quot;a+bc+5&quot;;;
- : expr =
Infix
  (Char '+',
   [Symbol (Char 'a');
    Infix (TeX &quot;_*&quot;, [Symbol (Char 'b'); Symbol (Char 'c')]);
    Number (&quot;5&quot;, &quot;&quot;)])</code></pre></dd></dl><section><header><h4 id="customization"><a href="#customization" class="anchor"></a>Customization</h4><p>You can modify these variables to taylor the parsing to your needs. In the string lists, LaTeX command are written without the initial backslash.</p></header><dl><dt class="spec value" id="val-float_separator"><a href="#val-float_separator" class="anchor"></a><code><span class="keyword">val</span> float_separator : char</code></dt><dd><p>The &quot;dot&quot; or &quot;comma&quot; used to represent floating point numbers.</p></dd></dl><dl><dt class="spec value" id="val-tex_symbols"><a href="#val-tex_symbols" class="anchor"></a><code><span class="keyword">val</span> tex_symbols : <span>string list</span></code></dt><dd><p>Names of LaTeX commands that are used as variable names, like <code>&quot;alpha&quot;</code>, <code>&quot;hbar&quot;</code>, etc.</p></dd></dl><dl><dt class="spec value" id="val-tex_unop"><a href="#val-tex_unop" class="anchor"></a><code><span class="keyword">val</span> tex_unop : <span>string list</span></code></dt><dd><p>Names of LaTeX commands that are used as unary operators, like <code>&quot;sin&quot;</code>, <code>&quot;hat&quot;</code>, etc.</p></dd></dl><dl><dt class="spec value" id="val-char_unop"><a href="#val-char_unop" class="anchor"></a><code><span class="keyword">val</span> char_unop : <span>char list</span></code></dt><dd><p>Chars that should be viewed as unary operators; for instance <code>'f'</code>.</p></dd></dl><dl><dt class="spec value" id="val-tex_binop"><a href="#val-tex_binop" class="anchor"></a><code><span class="keyword">val</span> tex_binop : <span>string list</span></code></dt><dd><p>Names of LaTeX binary prefix operators like <code>&quot;frac&quot;</code>.</p></dd></dl><dl><dt class="spec value" id="val-tex_infix"><a href="#val-tex_infix" class="anchor"></a><code><span class="keyword">val</span> tex_infix : <span>string list</span></code></dt><dd><p>Names of LaTeX symbols that are used as infix operators, like <code>&quot;times&quot;</code>. This list must contain the special string <code>&quot;_*&quot;</code> which is iternally used to represent hidden multiplication, as in <code>&quot;xy&quot;</code>.</p></dd></dl></section></section><section><header><h2 id="writing-latex-back"><a href="#writing-latex-back" class="anchor"></a>Writing LaTeX back</h2></header><dl><dt class="spec value" id="val-to_latex"><a href="#val-to_latex" class="anchor"></a><code><span class="keyword">val</span> to_latex : <a href="index.html#type-expr">expr</a> <span class="arrow">→</span> string</code></dt><dd><p>Produce a LaTeX string representing the given expression.</p></dd></dl><aside><p>Of course, the generated LaTeX will often differ from the original one. But we guarantee that two mathematically different expressions will generate different LaTeX.</p><p>Note that different expressions can be mathematically equal, for instance the expression:</p><pre><code class="ml">Infix (Char '+', 
       [Infix (Char '+', [Number (&quot;1&quot;, &quot;&quot;); Number (&quot;2&quot;, &quot;&quot;)]);
        Number (&quot;3&quot;, &quot;&quot;)])</code></pre><p>will generate the same LaTeX <code>&quot;1 + 2 + 3&quot;</code> as</p><pre><code class="ml">Infix (Char '+', 
       [Number (&quot;1&quot;, &quot;&quot;); Number (&quot;2&quot;, &quot;&quot;); Number (&quot;3&quot;, &quot;&quot;)])</code></pre><p>However the first one can never be obtained from parsing a LaTeX expression.</p><p>Alhough I didn't prove it, I think the following holds for any string <code>s</code>:</p><pre><code class="ml">parse s |&gt; to_latex |&gt; parse = parse s</code></pre><p>If not, please report a bug.</p></aside></section><section><header><h2 id="display-latex"><a href="#display-latex" class="anchor"></a>Display LaTeX</h2><p>These are just convenience functions to typeset and display LaTeX code.</p></header><dl><dt class="spec value" id="val-display"><a href="#val-display" class="anchor"></a><code><span class="keyword">val</span> display : string <span class="arrow">→</span> unit</code></dt><dd><p>If a PDF viewer is found, convert the given LaTeX formula to PDF and display it. Otherwise, use a browser with <a href="index.html#val-online"><code>online</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-html"><a href="#val-html" class="anchor"></a><code><span class="keyword">val</span> html : string <span class="arrow">→</span> unit</code></dt><dd><p>If the Hevea program is found, convert to html and open a browser. Otherwise, use <a href="index.html#val-online"><code>online</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-online"><a href="#val-online" class="anchor"></a><code><span class="keyword">val</span> online : <span>?&#8288;displaymode:bool</span> <span class="arrow">→</span> string <span class="arrow">→</span> unit</code></dt><dd><p>Open a browser for online typesetting with KaTeX.</p></dd></dl><dl><dt class="spec value" id="val-set_pdf_viewer"><a href="#val-set_pdf_viewer" class="anchor"></a><code><span class="keyword">val</span> set_pdf_viewer : string <span class="arrow">→</span> unit</code></dt><dt class="spec value" id="val-set_browser"><a href="#val-set_browser" class="anchor"></a><code><span class="keyword">val</span> set_browser : string <span class="arrow">→</span> unit</code></dt></dl></section></div></body></html>