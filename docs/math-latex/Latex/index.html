<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Latex (math-latex.Latex)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous"><script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script><script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">math-latex</a> &#x00BB; Latex</nav><h1>Module <code>Latex</code></h1><p>Parsing of simple LaTeX mathematical expressions.</p><dl><dt>author</dt><dd>San Vu Ngoc, 2020, Université de Rennes 1</dd></dl><nav class="toc"><ul><li><a href="#goal">Goal</a></li><li><a href="#warnings">Warnings</a></li><li><a href="#scanning-latex">Scanning LaTeX</a><ul><li><a href="#customization">Customization</a></li></ul></li><li><a href="#writing-latex-back">Writing LaTeX back</a></li><li><a href="#display-latex">Display LaTeX</a></li></ul></nav></header><section><header><h3 id="goal"><a href="#goal" class="anchor"></a>Goal</h3><p>The goal is to recognize the mathematical meaning of strings like</p><p><code>&quot;1.41+2x+5x^2 + \\sin t^2 + \\frac{A-B}2&quot;</code></p><p>(Which LaTeX renders as \(1.41+2x+5x^2 + \sin t^2 + \frac{A-B}2\).)</p><p>The resulting expression tree is</p><pre><code class="ml">Infix
  (Char '+',
   [Number (&quot;1&quot;, &quot;41&quot;);
    Infix (TeX &quot;_*&quot;, [Number (&quot;2&quot;, &quot;&quot;); Symbol (Char 'x')]);
    Infix
      (TeX &quot;_*&quot;,
       [Number (&quot;5&quot;, &quot;&quot;);
        Infix (Char '^', [Symbol (Char 'x'); Number (&quot;2&quot;, &quot;&quot;)])]);
    Unop (TeX &quot;sin&quot;, Infix (Char '^', [Symbol (Char 't'); Number (&quot;2&quot;, &quot;&quot;)]));
    Binop
      (TeX &quot;frac&quot;,
       Paren
         (Char '{', Infix (Char '-', [Symbol (Char 'A'); Symbol (Char 'B')])),
       Number (&quot;2&quot;, &quot;&quot;))])</code></pre></header></section><section><header><h3 id="warnings"><a href="#warnings" class="anchor"></a>Warnings</h3><p><em>Warning 1:</em> There cannot be a consistent translation between LaTeX maths and mathematical expressions, because LaTeX only expresses <b>typography</b> and not <b>mathematical meaning</b>. For instance <code>&quot;x^2&quot;</code> can both mean &quot;x to the power 2&quot; or &quot;the variable x with upper index 2&quot;.</p><p><em>Warning 2:</em> There are some differences with pure LaTeX:</p><p>* Numbers are treated like a unique symbol. Thus, <code>x^12</code> is parsed as <code>x^{12}</code> (but <code>x^2y</code> is 'correctly' parsed as <code>{x^2} * y</code>). <code>\\frac12</code> is an error, <code>\\frac12x</code> is parsed as <code>\\frac{12}{x}</code>. When in doubt, it's better to use brackets <code>{}</code>.</p><p>* Parenthesis <code>()</code> and brackets <code>[]</code> have the same role. Hence <code>x[a+b]</code> is parsed as <code>x * (a+b)</code></p><p>* Infix operators are not assumed to be associative or commutative: the order of arguments is preserved. For instance</p><pre><code class="ml"># parse &quot;a^b^c&quot;;;
- : expr =
Group (Char '^', [Symbol (Char 'a'); Symbol (Char 'b'); Symbol (Char 'c')])</code></pre><p>* Expressions like <code>\sin^2 x</code> are not allowed. Use <code>{\sin x}^2</code></p><p>* Arbitrary chars or TeX symbols can be declared as operators. For instance, if <code>f</code> is declared as a unary operator, then</p><p><code>5fx</code> ==&gt; <code>5 * f(x)</code></p><p><em>Warning 3:</em> The minus sign '-' is considered as an infix operator like '+', which can be confusing, but the result is actually easy to understand:</p><pre><code class="ml"># parse &quot;a-b-c&quot;;;
- : expr =
Group (Char '-', [Symbol (Char 'a'); Symbol (Char 'b'); Symbol (Char 'c')])</code></pre><p>The minus sign can also be transformed into a unary negation like in <code>&quot;-1&quot;</code>, but currently we do not allow this for '+' (<code>parse &quot;+1&quot;</code> raises an error); (this is for better syntax error checking.)</p></header></section><section><header><h2 id="scanning-latex"><a href="#scanning-latex" class="anchor"></a>Scanning LaTeX</h2></header><dl><dt class="spec type" id="type-number"><a href="#type-number" class="anchor"></a><code><span class="keyword">type</span> number</code><code> = string * string</code></dt><dd><p>123 is represented by <code>(&quot;123&quot;,&quot;&quot;)</code> and 12.234 is represented by <code>(&quot;12&quot;,
   &quot;234&quot;)</code>. These 'numbers' can easily be converted into 'true' numbers using for instance the Zarith library.</p></dd></dl><dl><dt class="spec type" id="type-symbol"><a href="#type-symbol" class="anchor"></a><code><span class="keyword">type</span> symbol</code><code> = </code><table class="variant"><tr id="type-symbol.Char" class="anchored"><td class="def constructor"><a href="#type-symbol.Char" class="anchor"></a><code>| </code><code><span class="constructor">Char</span> <span class="keyword">of</span> char</code></td></tr><tr id="type-symbol.TeX" class="anchored"><td class="def constructor"><a href="#type-symbol.TeX" class="anchor"></a><code>| </code><code><span class="constructor">TeX</span> <span class="keyword">of</span> string</code></td><td class="doc"><p>TeX &quot;alpha&quot; stands for &quot;\alpha&quot;</p></td></tr></table></dt><dt class="spec type" id="type-expr"><a href="#type-expr" class="anchor"></a><code><span class="keyword">and</span> expr</code><code> = </code><table class="variant"><tr id="type-expr.Number" class="anchored"><td class="def constructor"><a href="#type-expr.Number" class="anchor"></a><code>| </code><code><span class="constructor">Number</span> <span class="keyword">of</span> <a href="index.html#type-number">number</a></code></td></tr><tr id="type-expr.Symbol" class="anchored"><td class="def constructor"><a href="#type-expr.Symbol" class="anchor"></a><code>| </code><code><span class="constructor">Symbol</span> <span class="keyword">of</span> <a href="index.html#type-symbol">symbol</a></code></td></tr><tr id="type-expr.Unop" class="anchored"><td class="def constructor"><a href="#type-expr.Unop" class="anchor"></a><code>| </code><code><span class="constructor">Unop</span> <span class="keyword">of</span> <a href="index.html#type-symbol">symbol</a> * <a href="index.html#type-expr">expr</a></code></td></tr><tr id="type-expr.Binop" class="anchored"><td class="def constructor"><a href="#type-expr.Binop" class="anchor"></a><code>| </code><code><span class="constructor">Binop</span> <span class="keyword">of</span> <a href="index.html#type-symbol">symbol</a> * <a href="index.html#type-expr">expr</a> * <a href="index.html#type-expr">expr</a></code></td></tr><tr id="type-expr.Infix" class="anchored"><td class="def constructor"><a href="#type-expr.Infix" class="anchor"></a><code>| </code><code><span class="constructor">Infix</span> <span class="keyword">of</span> <a href="index.html#type-symbol">symbol</a> * <span><a href="index.html#type-expr">expr</a> list</span></code></td></tr><tr id="type-expr.Paren" class="anchored"><td class="def constructor"><a href="#type-expr.Paren" class="anchor"></a><code>| </code><code><span class="constructor">Paren</span> <span class="keyword">of</span> <a href="index.html#type-symbol">symbol</a> * <a href="index.html#type-expr">expr</a></code></td></tr></table></dt><dd><p>Mathematical expressions</p></dd></dl><dl><dt class="spec value" id="val-parse"><a href="#val-parse" class="anchor"></a><code><span class="keyword">val</span> parse : string <span class="arrow">→</span> <a href="index.html#type-expr">expr</a></code></dt><dd><p>This is the main function. Given a string containing LaTeX mathematics (without the '$'), <code>parse s</code> returns an abstract expression tree representing its mathematical content.</p><p>Example:</p><pre><code class="ml"># parse &quot;a+bc+5&quot;;;
- : expr =
Infix
  (Char '+',
   [Symbol (Char 'a');
    Infix (TeX &quot;_*&quot;, [Symbol (Char 'b'); Symbol (Char 'c')]);
    Number (&quot;5&quot;, &quot;&quot;)])</code></pre></dd></dl><section><header><h4 id="customization"><a href="#customization" class="anchor"></a>Customization</h4><p>You can modify these variables to taylor the parsing to your needs (currently you need to modify their definition in the source code). In the string lists, LaTeX command are written without the initial backslash.</p></header><dl><dt class="spec value" id="val-float_separator"><a href="#val-float_separator" class="anchor"></a><code><span class="keyword">val</span> float_separator : char</code></dt><dd><p>The &quot;dot&quot; or &quot;comma&quot; used to represent floating point numbers.</p></dd></dl><dl><dt class="spec value" id="val-tex_symbols"><a href="#val-tex_symbols" class="anchor"></a><code><span class="keyword">val</span> tex_symbols : <span>string list</span></code></dt><dd><p>Names of LaTeX commands that are used as variable names, like <code>&quot;alpha&quot;</code>, <code>&quot;hbar&quot;</code>, etc.</p></dd></dl><dl><dt class="spec value" id="val-tex_unop"><a href="#val-tex_unop" class="anchor"></a><code><span class="keyword">val</span> tex_unop : <span>string list</span></code></dt><dd><p>Names of LaTeX commands that are used as unary operators, like <code>&quot;sin&quot;</code>, <code>&quot;hat&quot;</code>, etc.</p></dd></dl><dl><dt class="spec value" id="val-char_unop"><a href="#val-char_unop" class="anchor"></a><code><span class="keyword">val</span> char_unop : <span>char list</span></code></dt><dd><p>Chars that should be viewed as unary operators; for instance <code>'f'</code>.</p></dd></dl><dl><dt class="spec value" id="val-tex_binop"><a href="#val-tex_binop" class="anchor"></a><code><span class="keyword">val</span> tex_binop : <span>string list</span></code></dt><dd><p>Names of LaTeX binary prefix operators like <code>&quot;frac&quot;</code>.</p></dd></dl><dl><dt class="spec value" id="val-tex_infix"><a href="#val-tex_infix" class="anchor"></a><code><span class="keyword">val</span> tex_infix : <span>string list</span></code></dt><dd><p>Names of LaTeX symbols that are used as infix operators, like <code>&quot;times&quot;</code>. This list must contain the special string <code>&quot;_*&quot;</code> which is iternally used to represent hidden multiplication, as in <code>&quot;xy&quot;</code>.</p></dd></dl></section></section><section><header><h2 id="writing-latex-back"><a href="#writing-latex-back" class="anchor"></a>Writing LaTeX back</h2></header><dl><dt class="spec value" id="val-to_latex"><a href="#val-to_latex" class="anchor"></a><code><span class="keyword">val</span> to_latex : <a href="index.html#type-expr">expr</a> <span class="arrow">→</span> string</code></dt><dd><p>Produce a LaTeX string representing the given expression.</p></dd></dl><aside><p>Of course, the generated LaTeX will often differ from the original one. But we guarantee that two mathematically different expressions will generate different LaTeX.</p><p>Note that different expressions can be mathematically equal, for instance the expression:</p><pre><code class="ml">Infix (Char '+', 
       [Infix (Char '+', [Number (&quot;1&quot;, &quot;&quot;); Number (&quot;2&quot;, &quot;&quot;)]);
        Number (&quot;3&quot;, &quot;&quot;)])</code></pre><p>will generate the same LaTeX <code>&quot;1 + 2 + 3&quot;</code> as</p><pre><code class="ml">Infix (Char '+', 
       [Number (&quot;1&quot;, &quot;&quot;); Number (&quot;2&quot;, &quot;&quot;); Number (&quot;3&quot;, &quot;&quot;)])</code></pre><p>However the first one can never be obtained from parsing a LaTeX expression.</p><p>Alhough I didn't prove it, I think the following holds for any string <code>s</code>:</p><pre><code class="ml">parse s |&gt; to_latex |&gt; parse = parse s</code></pre><p>If not, please report a bug.</p></aside></section><section><header><h2 id="display-latex"><a href="#display-latex" class="anchor"></a>Display LaTeX</h2><p>These are just convenience functions to typeset and display LaTeX code.</p></header><dl><dt class="spec value" id="val-display"><a href="#val-display" class="anchor"></a><code><span class="keyword">val</span> display : string <span class="arrow">→</span> unit</code></dt><dd><p>If a PDF viewer is found, convert the given LaTeX formula to PDF and display it. Otherwise, use a browser with <a href="index.html#val-online"><code>online</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-html"><a href="#val-html" class="anchor"></a><code><span class="keyword">val</span> html : string <span class="arrow">→</span> unit</code></dt><dd><p>If the Hevea program is found, convert to html and open a browser. Otherwise, use <a href="index.html#val-online"><code>online</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-online"><a href="#val-online" class="anchor"></a><code><span class="keyword">val</span> online : <span>?&#8288;displaymode:bool</span> <span class="arrow">→</span> string <span class="arrow">→</span> unit</code></dt><dd><p>Open a browser for online typesetting with KaTeX.</p></dd></dl><dl><dt class="spec value" id="val-set_pdf_viewer"><a href="#val-set_pdf_viewer" class="anchor"></a><code><span class="keyword">val</span> set_pdf_viewer : string <span class="arrow">→</span> unit</code></dt><dt class="spec value" id="val-set_browser"><a href="#val-set_browser" class="anchor"></a><code><span class="keyword">val</span> set_browser : string <span class="arrow">→</span> unit</code></dt></dl></section></div></body></html>